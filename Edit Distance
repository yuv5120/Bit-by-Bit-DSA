Levenshtein distance:

Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.
You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character

**
Approach (Dynamic Programming)

Notice that to compute dp[i][j], we only need:
dp[i-1][j] (previous row, same column → delete)
dp[i][j-1] (current row, previous column → insert)
dp[i-1][j-1] (previous row, previous column → replace)

** CODE:
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        if (m < n) return minDistance(word2, word1); 
        
        vector<int> prev(n+1, 0), curr(n+1, 0);
        for (int j = 0; j <= n; j++) prev[j] = j;
        
        for (int i = 1; i <= m; i++) {
            curr[0] = i;
            for (int j = 1; j <= n; j++) {
                if (word1[i-1] == word2[j-1]) {
                    curr[j] = prev[j-1];
                } else {
                    curr[j] = min({
                        prev[j] + 1, 
                        curr[j-1] + 1,
                        prev[j-1] + 1 
                    });
                }
            }
            prev = curr;
        }
        return prev[n];
    }
};

Time: O(m * n)
Space: O(min(m, n))
