You are given a string s. You can convert s to a palindrome by adding characters in front of it. 
Return the shortest palindrome you can find by performing this transformation.

Approach:
We can use string matching (KMP failure function):
Let rev = reverse(s).

Build t = s + '#' + rev.
Compute lps (longest prefix-suffix) array of t.
lps.back() gives the length of the longest palindromic prefix of s.
The answer = rev.substr(0, n - lps.back()) + s.

CODE:
class Solution {
public:
    string shortestPalindrome(string s) {
        string rev = s;
        reverse(rev.begin(), rev.end());
        string t = s + "#" + rev;

        vector<int> lps(t.size(), 0);
        for (int i = 1; i < t.size(); i++) {
            int j = lps[i-1];
            while (j > 0 && t[i] != t[j]) {
                j = lps[j-1];
            }
            if (t[i] == t[j]) j++;
            lps[i] = j;
        }
        
        int longestPrefix = lps.back();
        return rev.substr(0, s.size() - longestPrefix) + s;
    }
};

Complexity
Building LPS: O(n)
String reversal + concatenation: O(n)
Overall: O(n) time, O(n) space.
